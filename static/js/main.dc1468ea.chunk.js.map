{"version":3,"sources":["PathfindingVisualizer/Title.jsx","PathfindingVisualizer/Node/Node.jsx","Algorithms/Dijkstra.js","Algorithms/BreadthFirstSearch.js","Algorithms/DepthFirstSearch.js","Algorithms/AStarSearch.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Title","Node","this","props","row","col","isStart","isFinish","isWall","onMouseDown","onMouseEnter","onMouseUp","onClick","nodeClass","className","id","Component","getNodes","grid","allNodes","node","push","sortNodesByDistance","unvisitedNodes","sort","firstNode","secondNode","distance","updateUnvisitedNeighbors","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighboringNodes","length","filter","isVisted","isVisited","sortNodesByFvalue","openNodes","fValue","getHeuristic","finishNode","Math","abs","PathfindingVisualizer","state","isMousePressed","startNodeExists","finishNodeExists","startNode","visitedNodesInOrder","visitedNodes","nearestNode","shift","Infinity","dijkstra","shortestPathNodesOrder","nodesInShortestPath","currentNode","unshift","shortestPath","dijkstraAnimation","nodeIndex","setTimeout","dijkstraShortestPathAnimation","document","getElementById","nodeQueue","frontNode","marked","breadthFirstSearch","pathToFinishOrder","nodesInPath","pathToFinishNode","breadthFirstSearchAnimation","breadthFirstSearchPathAnimation","nodeStack","pop","depthFirstSearch","console","log","pathToFinishNodeDFS","depthFirstSearchAnimation","depthFirstSearchPathAnimation","closedNodes","heuristic","includes","tempFvalue","aStarSearch","shortestPathAStar","aStarSearchAnimation","aStarSearchPathAnimation","newGrid","createGrid","setState","toggleWallOnGrid","toggleNode","slice","newNode","dijkstraVisualization","breadthFirstSearchVisualization","depthFirstSearchVisualization","aStarSearchVisualization","map","rowIndex","key","mouseDownHandler","mouseEnterHandler","mouseUpHandler","mouseClickHandler","rowNum","colNum","createNode","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"iTAUeA,MARf,WACI,OACI,6BACI,wD,mCCDSC,G,6KACT,IAAD,EACwFC,KAAKC,MAA5FC,EADD,EACCA,IAAKC,EADN,EACMA,IAAKC,EADX,EACWA,QAASC,EADpB,EACoBA,SAAUC,EAD9B,EAC8BA,OAAQC,EADtC,EACsCA,YAAaC,EADnD,EACmDA,aAAcC,EADjE,EACiEA,UAAWC,EAD5E,EAC4EA,QAC7EC,EAAYN,EAAW,cAAgBD,EAAU,aAAeE,EAAS,YAAc,GAC7F,OACE,yBACEM,UAAS,eAAUD,GACnBE,GAAE,eAAUX,EAAV,YAAiBC,GACnBI,YAAa,kBAAMA,EAAYL,EAAKC,IACpCK,aAAc,kBAAMA,EAAaN,EAAKC,IACtCM,UAAW,kBAAMA,KACjBC,QAAS,kBAAMA,EAAQR,EAAKC,U,GAXFW,c,eCa5BC,EAAW,SAACC,GACd,IADuB,EACjBC,EAAW,GADM,cAELD,GAFK,IAEvB,2BAAwB,CAAC,IAAD,EAAbd,EAAa,sBACDA,GADC,IACpB,2BAAwB,CAAC,IAAdgB,EAAa,QACpBD,EAASE,KAAKD,IAFE,gCAFD,8BAOvB,OAAOD,GAGLG,EAAsB,SAACC,GACzBA,EAAeC,MAAK,SAACC,EAAWC,GAAZ,OAA2BD,EAAUE,SAAWD,EAAWC,aAG7EC,EAA2B,SAACV,EAAME,GACpC,IAD6C,EACvCS,EAAqBC,EAAsBZ,EAAME,GADV,cAEtBS,GAFsB,IAE7C,2BAA2C,CAAC,IAAjCE,EAAgC,QACvCA,EAASJ,SAAWP,EAAKO,SAAW,EACpCI,EAASC,aAAeZ,GAJiB,gCAQ3CU,EAAwB,SAACZ,EAAME,GACjC,IAAMa,EAAmB,GACjB7B,EAAagB,EAAbhB,IAAKC,EAAQe,EAARf,IAKb,OAJID,EAAM,GAAK6B,EAAiBZ,KAAKH,EAAKd,EAAM,GAAGC,IAC/CD,EAAMc,EAAKgB,OAAS,GAAKD,EAAiBZ,KAAKH,EAAKd,EAAM,GAAGC,IAC7DA,EAAM,GAAK4B,EAAiBZ,KAAKH,EAAKd,GAAKC,EAAM,IACjDA,EAAMa,EAAK,GAAGgB,OAAS,GAAKD,EAAiBZ,KAAKH,EAAKd,GAAKC,EAAM,IAC/D4B,EAAiBE,QAAO,SAAAJ,GAAQ,OAAKA,EAASK,aC1BnDN,EAAwB,SAACZ,EAAME,GACjC,IAD0C,EACpCS,EAAqBD,EAAyBV,EAAME,GADhB,cAErBS,GAFqB,IAE1C,2BAAyC,SAC5BG,aAAeZ,GAHc,8BAK1C,OAAOS,GAGLD,EAA2B,SAACV,EAAME,GACpC,IAAMa,EAAmB,GACjB7B,EAAagB,EAAbhB,IAAKC,EAAQe,EAARf,IAKb,OAJID,EAAM,GAAK6B,EAAiBZ,KAAKH,EAAKd,EAAM,GAAGC,IAC/CD,EAAMc,EAAKgB,OAAS,GAAKD,EAAiBZ,KAAKH,EAAKd,EAAM,GAAGC,IAC7DA,EAAM,GAAK4B,EAAiBZ,KAAKH,EAAKd,GAAKC,EAAM,IACjDA,EAAMa,EAAK,GAAGgB,OAAS,GAAKD,EAAiBZ,KAAKH,EAAKd,GAAKC,EAAM,IAC/D4B,EAAiBE,QAAO,SAAAJ,GAAQ,OAAKA,EAASM,cCfnDP,EAAwB,SAACZ,EAAME,GACjC,IAD0C,EACpCS,EAAqBD,EAAyBV,EAAME,GADhB,cAEnBS,GAFmB,IAE1C,2BAA2C,SAC9BG,aAAeZ,GAHc,8BAK1C,OAAOS,GAILD,EAA2B,SAACV,EAAME,GACpC,IAAMa,EAAmB,GACjB7B,EAAagB,EAAbhB,IAAKC,EAAQe,EAARf,IAKb,OAJIA,EAAM,GAAK4B,EAAiBZ,KAAKH,EAAKd,GAAKC,EAAM,IACjDD,EAAM,GAAK6B,EAAiBZ,KAAKH,EAAKd,EAAM,GAAGC,IAC/CD,EAAMc,EAAKgB,OAAS,GAAKD,EAAiBZ,KAAKH,EAAKd,EAAM,GAAGC,IAC7DA,EAAMa,EAAK,GAAGgB,OAAS,GAAKD,EAAiBZ,KAAKH,EAAKd,GAAKC,EAAM,IAC/D4B,EAAiBE,QAAO,SAAAJ,GAAQ,OAAKA,EAASM,cCJnDC,EAAoB,SAACC,GACvBA,EAAUf,MAAK,SAACC,EAAWC,GAAZ,OAA2BD,EAAUe,OAASd,EAAWc,WAGtEC,EAAe,SAACrB,EAAMsB,GAAgB,IAChCtC,EAAagB,EAAbhB,IAAKC,EAAQe,EAARf,IAEb,OADkBsC,KAAKC,IAAIF,EAAWrC,IAAMA,GAAOsC,KAAKC,IAAIF,EAAWtC,IAAMA,IAI3E0B,EAAwB,SAACZ,EAAME,GACjC,IAD0C,EACpCS,EAAqBD,EAAyBV,EAAME,GADhB,cAEnBS,GAFmB,IAE1C,2BAA2C,CAAC,IAAjCE,EAAgC,QACvCA,EAASJ,SAAWP,EAAKO,SAAW,EACpCI,EAASC,aAAeZ,GAJc,8BAM1C,OAAOS,GAILD,EAA2B,SAACV,EAAME,GACpC,IAAMa,EAAmB,GACjB7B,EAAagB,EAAbhB,IAAKC,EAAQe,EAARf,IAKb,OAJIA,EAAM,GAAK4B,EAAiBZ,KAAKH,EAAKd,GAAKC,EAAM,IACjDD,EAAM,GAAK6B,EAAiBZ,KAAKH,EAAKd,EAAM,GAAGC,IAC/CD,EAAMc,EAAKgB,OAAS,GAAKD,EAAiBZ,KAAKH,EAAKd,EAAM,GAAGC,IAC7DA,EAAMa,EAAK,GAAGgB,OAAS,GAAKD,EAAiBZ,KAAKH,EAAKd,GAAKC,EAAM,IAC/D4B,EAAiBE,QAAO,SAAAJ,GAAQ,OAAKA,EAASM,cClDpCQ,E,kDACnB,aAAe,IAAD,8BACZ,gBACKC,MAAQ,CACX5B,KAAM,GACN6B,gBAAgB,EAChBC,iBAAiB,EACjBC,kBAAkB,EAClBC,UAAW,GACXR,WAAY,IARF,E,oEAYW,IAAD,EACkBxC,KAAK4C,MAArC5B,EADc,EACdA,KAAMgC,EADQ,EACRA,UAAWR,EADH,EACGA,WACnBS,EJxBc,SAACjC,EAAMgC,EAAWR,GACtC,IAAMU,EAAe,GACrBF,EAAUvB,SAAW,EAErB,IADA,IAAMJ,EAAiBN,EAASC,GACvBK,EAAeW,QAAQ,CAC5BZ,EAAoBC,GACpB,IAAM8B,EAAc9B,EAAe+B,QACnC,IAAID,EAAY7C,OAAhB,CACA,GAAI6C,EAAY1B,WAAa4B,IAAU,OAAOH,EAG9C,GAFAC,EAAYjB,UAAW,EACvBgB,EAAa/B,KAAKgC,GACdA,IAAgBX,EAAY,OAAOU,EACvCxB,EAAyBV,EAAMmC,KIYPG,CAAStC,EAAMgC,EAAWR,GAChDe,EJyBkB,SAACf,GAGzB,IAFA,IAAMgB,EAAsB,GACxBC,EAAcjB,EACK,OAAhBiB,GACHD,EAAoBE,QAAQD,GAC5BA,EAAcA,EAAY3B,aAE9B,OAAO0B,EIhCwBG,CAAanB,GAC5CxC,KAAK4D,kBAAkBX,EAAqBM,K,wCAG5BN,EAAqBM,GACrC,IAD8D,IAAD,kBACpDM,GACP,GAAIA,IAAcZ,EAAoBjB,OAIpC,OAHA8B,YAAW,WACT,EAAKC,8BAA8BR,KAClC,GAAKM,GACF,CAAN,UAEFC,YAAW,WACT,IAAM5C,EAAO+B,EAAoBY,GACjCG,SAASC,eAAT,eAAgC/C,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOS,UAAY,sBACnE,GAAKiD,IAVDA,EAAY,EAAGA,GAAaZ,EAAoBjB,OAAQ6B,IAAa,CAAC,IAAD,IAArEA,GAAqE,qC,oDAclDN,GAC5B,IADqD,IAAD,WAC3CM,GACPC,YAAW,WACT,IAAM5C,EAAOqC,EAAuBM,GACpCG,SAASC,eAAT,eAAgC/C,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOS,UAAY,4BACnE,GAAKiD,IAJDA,EAAY,EAAGA,EAAYN,EAAuBvB,OAAQ6B,IAAc,EAAxEA,K,wDAQwB,IAAD,EACQ7D,KAAK4C,MAArC5B,EADwB,EACxBA,KAAMgC,EADkB,EAClBA,UAAWR,EADO,EACPA,WACnBS,EHvDwB,SAACjC,EAAMgC,EAAWR,GAChD,IAAMU,EAAe,GACfgB,EAAY,GAElB,IADAA,EAAU/C,KAAK6B,GACNkB,EAAUlC,QAAQ,CACvB,IAAMmC,EAAYD,EAAUd,QAC5B,IAAIe,EAAU7D,OAAd,CAGA,GAFA6D,EAAUhC,WAAY,EACtBe,EAAa/B,KAAKgD,GACdA,IAAc3B,EAAY,OAAOU,EACrC,IANuB,EAMjBvB,EAAqBC,EAAsBZ,EAAMmD,GANhC,cAOJxC,GAPI,IAOvB,2BAAuC,CAAC,IAA7BT,EAA4B,SACf,IAAhBA,EAAKkD,SACLlD,EAAKkD,QAAS,EACdF,EAAU/C,KAAKD,KAVA,iCGmDCmD,CAAmBrD,EAAMgC,EAAWR,GAC1D8B,EHlBsB,SAAC9B,GAG7B,IAFA,IAAM+B,EAAc,GAChBd,EAAcjB,EACK,OAAhBiB,GACHc,EAAYb,QAAQD,GACpBA,EAAcA,EAAY3B,aAE9B,OAAOyC,EGWmBC,CAAiBhC,GAC3CxC,KAAKyE,4BAA4BxB,EAAqBqB,K,kDAG5BrB,EAAqBqB,GAC/C,IADmE,IAAD,kBACzDT,GACP,GAAIA,IAAcZ,EAAoBjB,OAIpC,OAHA8B,YAAW,WACT,EAAKY,gCAAgCJ,KACpC,GAAKT,GACF,CAAN,UAEFC,YAAW,WACT,IAAM5C,EAAO+B,EAAoBY,GACjCG,SAASC,eAAT,eAAgC/C,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOS,UAAY,sBACnE,GAAKiD,IAVDA,EAAY,EAAGA,GAAaZ,EAAoBjB,OAAQ6B,IAAa,CAAC,IAAD,IAArEA,GAAqE,qC,sDAchDS,GAC9B,IADkD,IAAD,WACxCT,GACPC,YAAW,WACT,IAAM5C,EAAOoD,EAAkBT,GAC/BG,SAASC,eAAT,eAAgC/C,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOS,UAAY,4BACnE,GAAKiD,IAJDA,EAAY,EAAGA,EAAYS,EAAkBtC,OAAQ6B,IAAc,EAAnEA,K,sDAQsB,IAAD,EACU7D,KAAK4C,MAArC5B,EADsB,EACtBA,KAAMgC,EADgB,EAChBA,UAAWR,EADK,EACLA,WACnBS,EFtFsB,SAACjC,EAAMgC,EAAWR,GAC9C,IAAMU,EAAe,GACfyB,EAAY,GAGlB,IAFA3B,EAAUb,WAAY,EACtBwC,EAAUxD,KAAK6B,GACN2B,EAAU3C,QAAQ,CACvB,IAAMyB,EAAckB,EAAUC,MAG9B,GAFA1B,EAAa/B,KAAKsC,GAClBA,EAAYtB,WAAY,EACpBsB,IAAgBjB,EAAY,OAAOU,EACvC,IALuB,EAKjBvB,EAAqBC,EAAsBZ,EAAMyC,GALhC,cAMJ9B,GANI,IAMvB,2BAAuC,CAAC,IAA7BT,EAA4B,QAC/BA,EAAKZ,QACTqE,EAAUxD,KAAKD,IARI,+BAW3B,OAAOgC,EEsEqB2B,CAAiB7D,EAAMgC,EAAWR,GAC9DsC,QAAQC,WAAW9B,GACnB,IAAMqB,EFjDyB,SAAC9B,GAGhC,IAFA,IAAM+B,EAAc,GAChBd,EAAcjB,EACK,OAAhBiB,GACHc,EAAYb,QAAQD,GACpBA,EAAcA,EAAY3B,aAE9B,OAAOyC,EE0CmBS,CAAoBxC,GAC9CxC,KAAKiF,0BAA0BhC,EAAqBqB,K,gDAG5BrB,EAAqBqB,GAC7C,IADiE,IAAD,kBACvDT,GACP,GAAIA,IAAcZ,EAAoBjB,OAIpC,OAHA8B,YAAW,WACT,EAAKoB,8BAA8BZ,KAClC,GAAKT,GACF,CAAN,UAEFC,YAAW,WACT,IAAM5C,EAAO+B,EAAoBY,GACjCG,SAASC,eAAT,eAAgC/C,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOS,UAAY,sBACnE,GAAKiD,IAVDA,EAAY,EAAGA,GAAaZ,EAAoBjB,OAAQ6B,IAAa,CAAC,IAAD,IAArEA,GAAqE,qC,oDAclDS,GAC5B,IADgD,IAAD,WACtCT,GACPC,YAAW,WACT,IAAM5C,EAAOoD,EAAkBT,GAC/BG,SAASC,eAAT,eAAgC/C,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOS,UAAY,4BACnE,GAAKiD,IAJDA,EAAY,EAAGA,EAAYS,EAAkBtC,OAAQ6B,IAAc,EAAnEA,K,iDAQiB,IAAD,EACe7D,KAAK4C,MAArC5B,EADiB,EACjBA,KAAMgC,EADW,EACXA,UAAWR,EADA,EACAA,WACnBS,EDtHiB,SAACjC,EAAMgC,EAAWR,GACzC,IAAMH,EAAY,GACZ8C,EAAc,GAKpB,IAJAnC,EAAUvB,SAAW,EACrBuB,EAAUoC,UAAY7C,EAAaS,EAAWR,GAC9CQ,EAAUV,OAASU,EAAUvB,SAAWuB,EAAUoC,UAClD/C,EAAUlB,KAAK6B,GACNX,EAAUL,QAAQ,CACvBI,EAAkBC,GAClB,IAAMoB,EAAcpB,EAAUe,QAG9B,GAFAK,EAAYtB,WAAY,EACxBgD,EAAYhE,KAAKsC,GACbA,IAAgBjB,EAAY,OAAO2C,EACvC,IAAI1B,EAAYnD,OAAhB,CACA,IAPuB,EAOjBqB,EAAqBC,EAAsBZ,EAAMyC,GAPhC,cAQA9B,GARA,IAQvB,2BAA2C,CAAC,IAAjCE,EAAgC,QACvC,IAAIA,EAASvB,SACT6E,EAAYE,SAASxD,GAAzB,CACAA,EAASuD,UAAY7C,EAAaV,EAAUW,GAC5C,IAAM8C,EAAazD,EAASJ,SAAWI,EAASuD,UAChD,GAAK/C,EAAUgD,SAASxD,IAGnB,GAAIyD,GAAczD,EAASS,OAAQ,cAFpCD,EAAUlB,KAAKU,GAGnBA,EAASS,OAASgD,EAClBzD,EAASC,aAAe2B,IAlBL,gCAqB3B,OAAO0B,EC0FqBI,CAAYvE,EAAMgC,EAAWR,GACnDgC,EDzDuB,SAAChC,GAG9B,IAFA,IAAM+B,EAAc,GAChBd,EAAcjB,EACK,OAAhBiB,GACHc,EAAYb,QAAQD,GACpBA,EAAcA,EAAY3B,aAE9B,OAAOyC,ECkDkBiB,CAAkBhD,GAC3CxC,KAAKyF,qBAAqBxC,EAAqBuB,K,2CAI5BvB,EAAqBuB,GACxC,IAD2D,IAAD,kBACjDX,GACP,GAAIA,IAAcZ,EAAoBjB,OAIpC,OAHA8B,YAAW,WACT,EAAK4B,yBAAyBlB,KAC7B,GAAKX,GACF,CAAN,UAEFC,YAAW,WACT,IAAM5C,EAAO+B,EAAoBY,GACjCiB,QAAQC,IAAI7D,GACZ8C,SAASC,eAAT,eAAgC/C,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOS,UAAY,sBACnE,GAAKiD,IAXDA,EAAY,EAAGA,GAAaZ,EAAoBjB,OAAQ6B,IAAa,CAAC,IAAD,IAArEA,GAAqE,qC,+CAevDW,GACvB,IAD0C,IAAD,WAChCX,GACPC,YAAW,WACT,IAAM5C,EAAOsD,EAAiBX,GAC9BG,SAASC,eAAT,eAAgC/C,EAAKhB,IAArC,YAA4CgB,EAAKf,MAAOS,UAAY,4BACnE,GAAKiD,IAJDA,EAAY,EAAGA,EAAYW,EAAiBxC,OAAQ6B,IAAc,EAAlEA,K,0CAST,IAAM8B,EAAUC,IAChB5F,KAAK6F,SAAS,CAAE7E,KAAM2E,M,uCAGPzF,EAAKC,GACpB,GAAIH,KAAK4C,MAAME,iBAAmB9C,KAAK4C,MAAMG,iBAAkB,CAC7D,IAAM4C,EAAUG,EAAiB9F,KAAK4C,MAAM5B,KAAMd,EAAKC,GACvDH,KAAK6F,SAAS,CAAE7E,KAAM2E,EAAS9C,gBAAgB,O,wCAIjC3C,EAAKC,GACrB,IAAkC,IAA9BH,KAAK4C,MAAMC,eAAf,CACA,IAAM8C,EAAUG,EAAiB9F,KAAK4C,MAAM5B,KAAMd,EAAKC,GACvDH,KAAK6F,SAAS,CAAE7E,KAAM2E,O,uCAItB3F,KAAK6F,SAAS,CAAEhD,gBAAgB,M,wCAGhB3C,EAAKC,GACrB,IAAMwF,EAAU3F,KAAK+F,WAAW7F,EAAKC,GACrCH,KAAK6F,SAAS,CAAE7E,KAAM2E,M,iCAGbzF,EAAKC,GACd,IAAMwF,EAAU3F,KAAK4C,MAAM5B,KAAKgF,QAC1B9E,EAAOyE,EAAQzF,GAAKC,GAC1B,IAAKH,KAAK4C,MAAME,iBAAmB5B,EAAKd,QAAS,CAC/CJ,KAAK6F,SAAS,CAAE/C,iBAAkB9C,KAAK4C,MAAME,kBAC7C,IAAMmD,EAAO,2BACR/E,GADQ,IAEXd,SAAUc,EAAKd,UAEjBJ,KAAK6F,SAAS,CAAE7C,UAAWiD,IAC3BN,EAAQzF,GAAKC,GAAO8F,OAEjB,IAAKjG,KAAK4C,MAAMG,kBAAoB7B,EAAKb,SAAU,CACtDL,KAAK6F,SAAS,CAAE9C,kBAAmB/C,KAAK4C,MAAMG,mBAC9C,IAAMkD,EAAO,2BACR/E,GADQ,IAEXb,UAAWa,EAAKb,WAElBL,KAAK6F,SAAS,CAAErD,WAAYyD,IAC5BN,EAAQzF,GAAKC,GAAO8F,EAEtB,OAAON,I,+BAGC,IAAD,SAC0B3F,KAAK4C,MAA9B5B,EADD,EACCA,KAAM6B,EADP,EACOA,eACd,OACE,oCACE,4BAAQnC,QAAS,kBAAM,EAAKwF,0BAA5B,kCAGA,4BAAQxF,QAAS,kBAAM,EAAKyF,oCAA5B,kCAGA,4BAAQzF,QAAS,kBAAM,EAAK0F,kCAA5B,gCAGA,4BAAQ1F,QAAS,kBAAM,EAAK2F,6BAA5B,uBAGA,yBAAKzF,UAAU,QACZI,EAAKsF,KAAI,SAACpG,EAAKqG,GACd,OACE,yBAAKC,IAAKD,GACPrG,EAAIoG,KAAI,SAACpF,EAAM2C,GAAe,IACrB3D,EAAwCgB,EAAxChB,IAAKC,EAAmCe,EAAnCf,IAAKC,EAA8Bc,EAA9Bd,QAASC,EAAqBa,EAArBb,SAAUC,EAAWY,EAAXZ,OACrC,OACE,kBAAC,EAAD,CACEkG,IAAK3C,EACL3D,IAAKA,EACLC,IAAKA,EACLC,QAASA,EACTC,SAAUA,EACVC,OAAQA,EACRuC,eAAgBA,EAChBtC,YAAa,SAACL,EAAKC,GAAN,OAAc,EAAKsG,iBAAiBvG,EAAKC,IACtDK,aAAc,SAACN,EAAKC,GAAN,OAAc,EAAKuG,kBAAkBxG,EAAKC,IACxDM,UAAW,kBAAM,EAAKkG,kBACtBjG,QAAS,SAACR,EAAKC,GAAN,OAAc,EAAKyG,kBAAkB1G,EAAKC,mB,GAjOtBW,aA8O7C8E,EAAa,WAEjB,IADA,IAAM5E,EAAO,GACJ6F,EAAS,EAAGA,EAAS,GAAIA,IAAU,CAE1C,IADA,IAAM3G,EAAM,GACH4G,EAAS,EAAGA,EAAS,GAAIA,IAChC5G,EAAIiB,KAAK4F,EAAWF,EAAQC,IAE9B9F,EAAKG,KAAKjB,GAEZ,OAAOc,GAGH+F,EAAa,SAAC7G,EAAKC,GACvB,MAAO,CACLA,MACAD,MACAE,SAAS,EACTC,UAAU,EACVoB,SAAU4B,IACV+B,UAAW/B,IACXf,OAAQe,IACRlB,WAAW,EACXiC,QAAQ,EACR9D,QAAQ,EACRwB,aAAc,OAIZgE,EAAmB,SAAC9E,EAAMd,EAAKC,GACnC,IAAMwF,EAAU3E,EAAKgF,QACf9E,EAAOyE,EAAQzF,GAAKC,GACpB8F,EAAO,2BACR/E,GADQ,IAEXZ,QAASY,EAAKZ,SAGhB,OADAqF,EAAQzF,GAAKC,GAAO8F,EACbN,GC7QMqB,MATf,WACE,OACE,yBAAKpG,UAAU,OACb,kBAAC,EAAD,MACA,kBAAC,EAAD,QCGcqG,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFxD,SAASC,eAAe,SDyHpB,kBAAmBwD,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLlD,QAAQkD,MAAMA,EAAMC,c","file":"static/js/main.dc1468ea.chunk.js","sourcesContent":["import React from 'react'\n\nfunction Title() {\n    return (\n        <div>\n            <h1>Pathfinding Visualizer</h1>\n        </div>\n    )\n}\n\nexport default Title","import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const { row, col, isStart, isFinish, isWall, onMouseDown, onMouseEnter, onMouseUp, onClick } = this.props;\n    const nodeClass = isFinish ? \"node-finish\" : isStart ? \"node-start\" : isWall ? \"node-wall\" : \"\";\n    return (\n      <div\n        className={`node ${nodeClass}`}\n        id={`node-${row}-${col}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n        onClick={() => onClick(row, col)}\n      ></div>\n    );\n  }\n}\n","export const dijkstra = (grid, startNode, finishNode) => {\n    const visitedNodes = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getNodes(grid);\n    while (!!unvisitedNodes.length) {\n        sortNodesByDistance(unvisitedNodes);\n        const nearestNode = unvisitedNodes.shift();\n        if (nearestNode.isWall) continue;\n        if (nearestNode.distance === Infinity) return visitedNodes;\n        nearestNode.isVisted = true;\n        visitedNodes.push(nearestNode);\n        if (nearestNode === finishNode) return visitedNodes;\n        updateUnvisitedNeighbors(grid, nearestNode);\n    }\n}\n\n\nconst getNodes = (grid) => {\n    const allNodes = []\n    for (const row of grid) {\n        for (const node of row) {\n            allNodes.push(node);\n        }\n    }\n    return allNodes;\n}\n\nconst sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((firstNode, secondNode) => firstNode.distance - secondNode.distance);\n}\n\nconst updateUnvisitedNeighbors = (grid, node) => {\n    const unvisitedNeighbors = getUnvisitedNeighbors(grid, node);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}\n\nconst getUnvisitedNeighbors = (grid, node) => {\n    const neighboringNodes = [];\n    const { row, col } = node;\n    if (row > 0) { neighboringNodes.push(grid[row - 1][col]) };\n    if (row < grid.length - 1) { neighboringNodes.push(grid[row + 1][col]) };\n    if (col > 0) { neighboringNodes.push(grid[row][col - 1]) };\n    if (col < grid[0].length - 1) { neighboringNodes.push(grid[row][col + 1]) };\n    return neighboringNodes.filter(neighbor => !neighbor.isVisted);\n}\n\n\nexport const shortestPath = (finishNode) => {\n    const nodesInShortestPath = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPath;\n}","export const breadthFirstSearch = (grid, startNode, finishNode) => {\n    const visitedNodes = [];\n    const nodeQueue = [];\n    nodeQueue.push(startNode);\n    while (!!nodeQueue.length) {\n        const frontNode = nodeQueue.shift();\n        if (frontNode.isWall) continue;\n        frontNode.isVisited = true;\n        visitedNodes.push(frontNode);\n        if (frontNode === finishNode) return visitedNodes;\n        const unvisitedNeighbors = getUnvisitedNeighbors(grid, frontNode);\n        for (const node of unvisitedNeighbors) {\n            if (node.marked === false) {\n                node.marked = true;\n                nodeQueue.push(node);\n            }\n        }\n    }\n}\n\nconst getUnvisitedNeighbors = (grid, node) => {\n    const unvisitedNeighbors = updateUnvisitedNeighbors(grid, node)\n    for (let neighbor of unvisitedNeighbors) {\n        neighbor.previousNode = node;\n    }\n    return unvisitedNeighbors\n}\n\nconst updateUnvisitedNeighbors = (grid, node) => {\n    const neighboringNodes = [];\n    const { row, col } = node;\n    if (row > 0) { neighboringNodes.push(grid[row - 1][col]) };\n    if (row < grid.length - 1) { neighboringNodes.push(grid[row + 1][col]) }\n    if (col > 0) { neighboringNodes.push(grid[row][col - 1]) };\n    if (col < grid[0].length - 1) { neighboringNodes.push(grid[row][col + 1]) };\n    return neighboringNodes.filter(neighbor => !neighbor.isVisited);\n}\n\nexport const pathToFinishNode = (finishNode) => {\n    const nodesInPath = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInPath;\n}","export const depthFirstSearch = (grid, startNode, finishNode) => {\n    const visitedNodes = [];\n    const nodeStack = [];\n    startNode.isVisited = true;\n    nodeStack.push(startNode);\n    while (!!nodeStack.length) {\n        const currentNode = nodeStack.pop();\n        visitedNodes.push(currentNode);\n        currentNode.isVisited = true;\n        if (currentNode === finishNode) return visitedNodes;\n        const unvisitedNeighbors = getUnvisitedNeighbors(grid, currentNode);\n        for (const node of unvisitedNeighbors) {\n            if (node.isWall) continue;\n            nodeStack.push(node);\n        }\n    }\n    return visitedNodes;\n}\n\n\nconst getUnvisitedNeighbors = (grid, node) => {\n    const unvisitedNeighbors = updateUnvisitedNeighbors(grid, node)\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.previousNode = node;\n    }\n    return unvisitedNeighbors;\n}\n\n\nconst updateUnvisitedNeighbors = (grid, node) => {\n    const neighboringNodes = [];\n    const { row, col } = node;\n    if (col > 0) { neighboringNodes.push(grid[row][col - 1]) };\n    if (row > 0) { neighboringNodes.push(grid[row - 1][col]) };\n    if (row < grid.length - 1) { neighboringNodes.push(grid[row + 1][col]) };\n    if (col < grid[0].length - 1) { neighboringNodes.push(grid[row][col + 1]) };\n    return neighboringNodes.filter(neighbor => !neighbor.isVisited);\n}\n\nexport const pathToFinishNodeDFS = (finishNode) => {\n    const nodesInPath = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInPath;\n}","export const aStarSearch = (grid, startNode, finishNode) => {\n    const openNodes = [];\n    const closedNodes = [];\n    startNode.distance = 0;\n    startNode.heuristic = getHeuristic(startNode, finishNode);\n    startNode.fValue = startNode.distance + startNode.heuristic;\n    openNodes.push(startNode);\n    while (!!openNodes.length) {\n        sortNodesByFvalue(openNodes);\n        const currentNode = openNodes.shift();\n        currentNode.isVisited = true;\n        closedNodes.push(currentNode);\n        if (currentNode === finishNode) return closedNodes;\n        if (currentNode.isWall) continue;\n        const unvisitedNeighbors = getUnvisitedNeighbors(grid, currentNode);\n        for (const neighbor of unvisitedNeighbors) {\n            if (neighbor.isWall) continue;\n            if (closedNodes.includes(neighbor)) continue;\n            neighbor.heuristic = getHeuristic(neighbor, finishNode);\n            const tempFvalue = neighbor.distance + neighbor.heuristic;\n            if (!openNodes.includes(neighbor)) {\n                openNodes.push(neighbor);\n            }\n            else if (tempFvalue >= neighbor.fValue) continue;\n            neighbor.fValue = tempFvalue;\n            neighbor.previousNode = currentNode;\n        }\n    }\n    return closedNodes;\n}\n\n\nconst sortNodesByFvalue = (openNodes) => {\n    openNodes.sort((firstNode, secondNode) => firstNode.fValue - secondNode.fValue);\n}\n\nconst getHeuristic = (node, finishNode) => {\n    const { row, col } = node;\n    const heuristic = Math.abs(finishNode.col - col) + Math.abs(finishNode.row - row);\n    return heuristic;\n}\n\nconst getUnvisitedNeighbors = (grid, node) => {\n    const unvisitedNeighbors = updateUnvisitedNeighbors(grid, node)\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n    return unvisitedNeighbors;\n}\n\n\nconst updateUnvisitedNeighbors = (grid, node) => {\n    const neighboringNodes = [];\n    const { row, col } = node;\n    if (col > 0) { neighboringNodes.push(grid[row][col - 1]) };\n    if (row > 0) { neighboringNodes.push(grid[row - 1][col]) };\n    if (row < grid.length - 1) { neighboringNodes.push(grid[row + 1][col]) };\n    if (col < grid[0].length - 1) { neighboringNodes.push(grid[row][col + 1]) };\n    return neighboringNodes.filter(neighbor => !neighbor.isVisited);\n}\n\nexport const shortestPathAStar = (finishNode) => {\n    const nodesInPath = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInPath;\n}","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\n\nimport \"./PathfindingVisualizer.css\";\nimport { dijkstra, shortestPath } from \"../Algorithms/Dijkstra\";\nimport { breadthFirstSearch, pathToFinishNode } from \"../Algorithms/BreadthFirstSearch\";\nimport { depthFirstSearch, pathToFinishNodeDFS } from \"../Algorithms/DepthFirstSearch\";\nimport { aStarSearch, shortestPathAStar } from \"../Algorithms/AStarSearch\";\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      isMousePressed: false,\n      startNodeExists: false,\n      finishNodeExists: false,\n      startNode: {},\n      finishNode: {}\n    };\n  }\n\n  dijkstraVisualization() {\n    const { grid, startNode, finishNode } = this.state;\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const shortestPathNodesOrder = shortestPath(finishNode);\n    this.dijkstraAnimation(visitedNodesInOrder, shortestPathNodesOrder);\n  }\n\n  dijkstraAnimation(visitedNodesInOrder, shortestPathNodesOrder) {\n    for (let nodeIndex = 0; nodeIndex <= visitedNodesInOrder.length; nodeIndex++) {\n      if (nodeIndex === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.dijkstraShortestPathAnimation(shortestPathNodesOrder);\n        }, 10 * nodeIndex);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[nodeIndex];\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n      }, 10 * nodeIndex);\n    }\n  }\n\n  dijkstraShortestPathAnimation(shortestPathNodesOrder) {\n    for (let nodeIndex = 0; nodeIndex < shortestPathNodesOrder.length; nodeIndex++) {\n      setTimeout(() => {\n        const node = shortestPathNodesOrder[nodeIndex];\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path\";\n      }, 50 * nodeIndex);\n    }\n  }\n\n  breadthFirstSearchVisualization() {\n    const { grid, startNode, finishNode } = this.state;\n    const visitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\n    const pathToFinishOrder = pathToFinishNode(finishNode);\n    this.breadthFirstSearchAnimation(visitedNodesInOrder, pathToFinishOrder);\n  }\n\n  breadthFirstSearchAnimation(visitedNodesInOrder, pathToFinishOrder) {\n    for (let nodeIndex = 0; nodeIndex <= visitedNodesInOrder.length; nodeIndex++) {\n      if (nodeIndex === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.breadthFirstSearchPathAnimation(pathToFinishOrder)\n        }, 10 * nodeIndex);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[nodeIndex];\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n      }, 10 * nodeIndex);\n    }\n  }\n\n  breadthFirstSearchPathAnimation(pathToFinishOrder) {\n    for (let nodeIndex = 0; nodeIndex < pathToFinishOrder.length; nodeIndex++) {\n      setTimeout(() => {\n        const node = pathToFinishOrder[nodeIndex];\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path\";\n      }, 50 * nodeIndex);\n    }\n  }\n\n  depthFirstSearchVisualization() {\n    const { grid, startNode, finishNode } = this.state;\n    const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\n    console.log(typeof visitedNodesInOrder);\n    const pathToFinishOrder = pathToFinishNodeDFS(finishNode);\n    this.depthFirstSearchAnimation(visitedNodesInOrder, pathToFinishOrder);\n  }\n\n  depthFirstSearchAnimation(visitedNodesInOrder, pathToFinishOrder) {\n    for (let nodeIndex = 0; nodeIndex <= visitedNodesInOrder.length; nodeIndex++) {\n      if (nodeIndex === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.depthFirstSearchPathAnimation(pathToFinishOrder)\n        }, 10 * nodeIndex);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[nodeIndex];\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n      }, 10 * nodeIndex);\n    }\n  }\n\n  depthFirstSearchPathAnimation(pathToFinishOrder) {\n    for (let nodeIndex = 0; nodeIndex < pathToFinishOrder.length; nodeIndex++) {\n      setTimeout(() => {\n        const node = pathToFinishOrder[nodeIndex];\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path\";\n      }, 50 * nodeIndex);\n    }\n  }\n\n  aStarSearchVisualization() {\n    const { grid, startNode, finishNode } = this.state;\n    const visitedNodesInOrder = aStarSearch(grid, startNode, finishNode);\n    const pathToFinishNode = shortestPathAStar(finishNode);\n    this.aStarSearchAnimation(visitedNodesInOrder, pathToFinishNode);\n    // this.aStarSearchPathAnimation(pathToFinishNode);\n  }\n\n  aStarSearchAnimation(visitedNodesInOrder, pathToFinishNode) {\n    for (let nodeIndex = 0; nodeIndex <= visitedNodesInOrder.length; nodeIndex++) {\n      if (nodeIndex === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.aStarSearchPathAnimation(pathToFinishNode)\n        }, 10 * nodeIndex);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[nodeIndex];\n        console.log(node);\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n      }, 10 * nodeIndex);\n    }\n  }\n\n  aStarSearchPathAnimation(pathToFinishNode) {\n    for (let nodeIndex = 0; nodeIndex < pathToFinishNode.length; nodeIndex++) {\n      setTimeout(() => {\n        const node = pathToFinishNode[nodeIndex];\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path\";\n      }, 50 * nodeIndex);\n    }\n  }\n\n  componentDidMount() {\n    const newGrid = createGrid();\n    this.setState({ grid: newGrid });\n  }\n\n  mouseDownHandler(row, col) {\n    if (this.state.startNodeExists && this.state.finishNodeExists) {\n      const newGrid = toggleWallOnGrid(this.state.grid, row, col);\n      this.setState({ grid: newGrid, isMousePressed: true });\n    }\n  }\n\n  mouseEnterHandler(row, col) {\n    if (this.state.isMousePressed === false) return;\n    const newGrid = toggleWallOnGrid(this.state.grid, row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  mouseUpHandler() {\n    this.setState({ isMousePressed: false });\n  }\n\n  mouseClickHandler(row, col) {\n    const newGrid = this.toggleNode(row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  toggleNode(row, col) {\n    const newGrid = this.state.grid.slice();\n    const node = newGrid[row][col];\n    if (!this.state.startNodeExists || node.isStart) {\n      this.setState({ startNodeExists: !this.state.startNodeExists });\n      const newNode = {\n        ...node,\n        isStart: !node.isStart\n      };\n      this.setState({ startNode: newNode })\n      newGrid[row][col] = newNode;\n    }\n    else if (!this.state.finishNodeExists || node.isFinish) {\n      this.setState({ finishNodeExists: !this.state.finishNodeExists });\n      const newNode = {\n        ...node,\n        isFinish: !node.isFinish\n      };\n      this.setState({ finishNode: newNode })\n      newGrid[row][col] = newNode;\n    }\n    return newGrid;\n  }\n\n  render() {\n    const { grid, isMousePressed } = this.state;\n    return (\n      <>\n        <button onClick={() => this.dijkstraVisualization()}>\n          Visualize Dijkstra's Algorithm\n        </button>\n        <button onClick={() => this.breadthFirstSearchVisualization()}>\n          Visualize Breadth First Search\n        </button>\n        <button onClick={() => this.depthFirstSearchVisualization()}>\n          Visualize Depth First Search\n        </button>\n        <button onClick={() => this.aStarSearchVisualization()}>\n          Visualize A* Search\n        </button>\n        <div className=\"grid\">\n          {grid.map((row, rowIndex) => {\n            return (\n              <div key={rowIndex}>\n                {row.map((node, nodeIndex) => {\n                  const { row, col, isStart, isFinish, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIndex}\n                      row={row}\n                      col={col}\n                      isStart={isStart}\n                      isFinish={isFinish}\n                      isWall={isWall}\n                      isMousePressed={isMousePressed}\n                      onMouseDown={(row, col) => this.mouseDownHandler(row, col)}\n                      onMouseEnter={(row, col) => this.mouseEnterHandler(row, col)}\n                      onMouseUp={() => this.mouseUpHandler()}\n                      onClick={(row, col) => this.mouseClickHandler(row, col)}\n                    ></Node>\n                  );\n                })}\n              </div>\n            )\n          })}\n        </div>\n      </>\n    )\n  }\n}\n\nconst createGrid = () => {\n  const grid = [];\n  for (let rowNum = 0; rowNum < 20; rowNum++) {\n    const row = [];\n    for (let colNum = 0; colNum < 50; colNum++) {\n      row.push(createNode(rowNum, colNum));\n    }\n    grid.push(row);\n  }\n  return grid;\n}\n\nconst createNode = (row, col) => {\n  return {\n    col,\n    row,\n    isStart: false,\n    isFinish: false,\n    distance: Infinity,\n    heuristic: Infinity,\n    fValue: Infinity,\n    isVisited: false,\n    marked: false,\n    isWall: false,\n    previousNode: null\n  }\n}\n\nconst toggleWallOnGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n}\n","import React from 'react';\nimport './App.css';\nimport Title from './PathfindingVisualizer/Title';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Title></Title>\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}